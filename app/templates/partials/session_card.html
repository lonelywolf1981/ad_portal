<div class="card shadow-sm">
  <div class="card-body">
    <h1 class="h6 mb-2">Сеанс</h1>

    <div class="row small">
      <div class="col-md-6">
        <div class="text-secondary">Пользователь: <strong>{{ user.get("username","") }}</strong></div>
        <div class="text-secondary">Тип: <strong>{{ user.get("auth","") }}</strong></div>
        <div class="text-secondary">Доступ к настройкам: <strong>{{ "Да" if user.get("settings") else "Нет" }}</strong></div>
      </div>
      <div class="col-md-6">
        <div class="text-secondary">Отображаемое имя: <strong>{{ user.get("display_name","") }}</strong></div>
      </div>
    </div>

    <div class="mt-3 pt-3 border-top">
      <div class="h6 mb-2">Статистика</div>

      <div class="d-flex flex-wrap justify-content-between align-items-end gap-3">
        <div class="flex-grow-1" style="min-width: 220px;">
          <div class="text-secondary fs-4">Пользователей AD: <span class="fw-semibold text-info fs-4">{{ ad_users_total }}</span></div>
        </div>

        <div class="flex-grow-1 text-md-center" style="min-width: 260px;">
          <div class="text-secondary fs-4">Активных (enabled): <span class="fw-semibold text-info fs-4">{{ ad_users_enabled }}</span></div>
        </div>

        <div class="flex-grow-1 text-md-end" style="min-width: 300px;">
          <div class="text-secondary fs-4">Онлайн (по последнему скану): <span class="fw-semibold text-info fs-4">{{ online_users }}</span></div>
        </div>
      </div>
    </div>

    <div class="mt-3 pt-3 border-top">
      <div class="d-flex flex-wrap align-items-center justify-content-between gap-2 mb-2">
        <div class="fw-semibold">Динамика метрик</div>
        <button type="button" class="btn btn-sm btn-outline-secondary" id="stats-chart-collapse-btn">Свернуть</button>
      </div>

      <div id="stats-chart-wrap">
        <div class="d-flex flex-wrap align-items-center gap-2 mb-2">
          <div class="btn-group btn-group-sm" role="group" aria-label="Метрика графика">
            <button type="button" class="btn btn-outline-primary" data-chart-metric="total">Всего пользователей</button>
            <button type="button" class="btn btn-outline-primary" data-chart-metric="enabled">Активных</button>
            <button type="button" class="btn btn-outline-primary active" data-chart-metric="online">Онлайн</button>
          </div>
          <select class="form-select form-select-sm" id="stats-period-select" style="width:auto;">
            <option value="5m">Последние 5 минут</option>
            <option value="15m" selected>Последние 15 минут</option>
            <option value="30m">Последние 30 минут</option>
            <option value="1h">Последний 1 час</option>
            <option value="3h">Последние 3 часа</option>
            <option value="6h">Последние 6 часов</option>
            <option value="12h">Последние 12 часов</option>
            <option value="24h">Последние 24 часа</option>
            <option value="7d">Последние 7 дней</option>
            <option value="30d">Последние 30 дней</option>
            <option value="90d">Последние 3 месяца</option>
            <option value="180d">Последние 6 месяцев</option>
            <option value="365d">Последние 12 месяцев</option>
            <option value="custom">Произвольный период</option>
          </select>
        </div>

        <div class="d-flex flex-wrap align-items-center gap-2 mb-2 d-none" id="stats-custom-range">
          <label class="small text-secondary" for="stats-date-from">С</label>
          <input id="stats-date-from" type="datetime-local" class="form-control form-control-sm" style="max-width:220px;">
          <label class="small text-secondary" for="stats-date-to">По</label>
          <input id="stats-date-to" type="datetime-local" class="form-control form-control-sm" style="max-width:220px;">
          <button type="button" class="btn btn-sm btn-outline-primary" id="stats-custom-apply">Применить</button>
        </div>

        <canvas id="stats-chart-canvas" height="170" style="display:block; width:calc(100% - 20px); margin:0 10px;"></canvas>
        <div id="stats-chart-hint" class="small text-secondary mt-1"></div>
      </div>
    </div>

    <div class="mt-3 pt-2 border-top small text-secondary">
      <div class="mb-1">Статус: {% if net_scan_is_running %}<span class="badge text-bg-info">Выполняется…</span>{% else %}<span class="badge text-bg-secondary">Ожидание</span>{% endif %}</div>
      <div>Сканирований (за период хранения): <strong>{{ stats_scans_total or 0 }}</strong></div>
      <div>Последний запуск: <strong>{{ net_scan_last_run if net_scan_last_run else "—" }}</strong></div>
      <div>Результат: {% if net_scan_last_summary %}{{ net_scan_last_summary }}{% else %}—{% endif %}</div>
    </div>
  </div>
</div>

<script>
(function(){
  const points = {{ stats_history_points|tojson }};
  const retentionDays = Number({{ stats_retention_days or 30 }});
  const canvas = document.getElementById("stats-chart-canvas");
  const hint = document.getElementById("stats-chart-hint");
  const periodSelect = document.getElementById("stats-period-select");
  const customWrap = document.getElementById("stats-custom-range");
  const dateFrom = document.getElementById("stats-date-from");
  const dateTo = document.getElementById("stats-date-to");
  const customApply = document.getElementById("stats-custom-apply");
  const collapseBtn = document.getElementById("stats-chart-collapse-btn");
  const chartWrap = document.getElementById("stats-chart-wrap");
  if (!canvas || !hint || !periodSelect || !customWrap || !dateFrom || !dateTo || !customApply || !collapseBtn || !chartWrap) return;

  const metricLabels = {
    total: "Всего пользователей",
    enabled: "Активных",
    online: "Онлайн"
  };
  const presetMinutes = {
    "5m": 5,
    "15m": 15,
    "30m": 30,
    "1h": 60,
    "3h": 180,
    "6h": 360,
    "12h": 720,
    "24h": 1440,
    "7d": 7 * 1440,
    "30d": 30 * 1440,
    "90d": 90 * 1440,
    "180d": 180 * 1440,
    "365d": 365 * 1440
  };
  const maxMinutes = Math.max(1, retentionDays * 1440);

  Array.from(periodSelect.options).forEach(function(opt){
    if (Object.prototype.hasOwnProperty.call(presetMinutes, opt.value)) {
      opt.disabled = presetMinutes[opt.value] > maxMinutes;
    }
  });

  let metric = "online";
  let period = "15m";
  let collapsed = false;
  const lsMetricKey = "ad_portal_stats_metric";
  const lsPeriodKey = "ad_portal_stats_period";
  const lsFromKey = "ad_portal_stats_from";
  const lsToKey = "ad_portal_stats_to";
  const lsCollapsedKey = "ad_portal_stats_collapsed";

  function parseLocalDateInput(s){
    const ms = Date.parse(s || "");
    return Number.isFinite(ms) ? ms : null;
  }

  function toLocalInputValue(ms){
    if (!Number.isFinite(ms)) return "";
    const d = new Date(ms);
    const pad = function(n){ return String(n).padStart(2, "0"); };
    return d.getFullYear() + "-" + pad(d.getMonth() + 1) + "-" + pad(d.getDate()) + "T" + pad(d.getHours()) + ":" + pad(d.getMinutes());
  }

  function applyCollapseState(){
    chartWrap.classList.toggle("d-none", collapsed);
    collapseBtn.textContent = collapsed ? "Развернуть" : "Свернуть";
  }

  function getPeriodWindowMs() {
    let fromMs = null;
    let toMs = Date.now();

    if (period === "custom") {
      fromMs = parseLocalDateInput(dateFrom.value);
      const customTo = parseLocalDateInput(dateTo.value);
      if (customTo !== null) toMs = customTo;
      if (fromMs === null) return null;
      if (toMs < fromMs) return null;
    } else {
      const mins = presetMinutes[period] || 15;
      fromMs = Date.now() - (mins * 60 * 1000);
    }
    return { fromMs: fromMs, toMs: toMs };
  }

  function pickPeriodPoints(windowMs) {
    if (!Array.isArray(points) || !points.length || !windowMs) return [];
    const fromMs = windowMs.fromMs;
    const toMs = windowMs.toMs;
    const out = points.filter(function(p){
      const ts = Date.parse(p.ts || "");
      return Number.isFinite(ts) && ts >= fromMs && ts <= toMs;
    });
    out.sort(function(a, b){
      return Date.parse(a.ts || "") - Date.parse(b.ts || "");
    });
    return out;
  }

  function formatTick(ms, spanMs){
    const d = new Date(ms);
    if (spanMs <= 24 * 60 * 60 * 1000) {
      return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }
    if (spanMs <= 45 * 24 * 60 * 60 * 1000) {
      return d.toLocaleDateString([], { day: "2-digit", month: "2-digit" }) + " " +
             d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }
    return d.toLocaleDateString([], { day: "2-digit", month: "2-digit", year: "2-digit" });
  }

  function draw(){
    const windowMs = getPeriodWindowMs();
    if (!windowMs) {
      hint.textContent = "Некорректный период (проверьте даты 'С' и 'По').";
      return;
    }
    const fromMs = windowMs.fromMs;
    const toMs = windowMs.toMs;
    const spanMs = Math.max(1, toMs - fromMs);

    const pts = pickPeriodPoints(windowMs).filter(function(p){
      return p[metric] !== null && p[metric] !== undefined;
    });

    const ctx = canvas.getContext("2d");
    const containerWidth = (canvas.parentElement && canvas.parentElement.clientWidth) ? canvas.parentElement.clientWidth : canvas.clientWidth;
    const w = Math.max(320, (containerWidth || 640) - 20);
    const h = 200;
    canvas.width = w;
    canvas.height = h;

    ctx.clearRect(0, 0, w, h);

    const padTop = 12;
    const padBottom = 32;
    const padLeft = 52;
    const padRight = 10;
    const plotH = Math.max(1, h - padTop - padBottom);
    const plotW = Math.max(1, w - padLeft - padRight);

    // Axes and grid (Grafana/Zabbix-like look)
    ctx.strokeStyle = "rgba(108,117,125,0.25)";
    ctx.lineWidth = 1;
    for (let k = 0; k <= 4; k++) {
      const gy = padTop + (k * plotH / 4);
      ctx.beginPath();
      ctx.moveTo(padLeft, gy);
      ctx.lineTo(w - padRight, gy);
      ctx.stroke();
    }
    for (let k = 0; k <= 5; k++) {
      const gx = padLeft + (k * plotW / 5);
      ctx.beginPath();
      ctx.moveTo(gx, padTop);
      ctx.lineTo(gx, padTop + plotH);
      ctx.stroke();
    }

    if (!pts.length) {
      ctx.fillStyle = "#6c757d";
      ctx.font = "13px sans-serif";
      ctx.fillText("Недостаточно данных за выбранный период.", padLeft + 8, padTop + 16);
      hint.textContent = "Недостаточно данных за выбранный период. Точки добавляются после каждого завершённого сканирования.";
      // Draw time scale even without points.
      ctx.fillStyle = "#6c757d";
      ctx.font = "11px sans-serif";
      ctx.textAlign = "center";
      for (let k = 0; k <= 5; k++) {
        const t = fromMs + (k * spanMs / 5);
        const gx = padLeft + (k * plotW / 5);
        ctx.fillText(formatTick(t, spanMs), gx, h - 10);
      }
      ctx.textAlign = "start";
      return;
    }

    const values = pts.map(function(p){ return Number(p[metric]); });
    const minV = Math.min.apply(null, values);
    const maxV = Math.max.apply(null, values);
    const range = Math.max(1, maxV - minV);

    function xByTs(tsMs){
      const ratio = (tsMs - fromMs) / spanMs;
      const clamped = Math.min(1, Math.max(0, ratio));
      return padLeft + (clamped * plotW);
    }
    function y(v){
      return padTop + ((maxV - v) * plotH / range);
    }

    // Y-axis labels.
    ctx.fillStyle = "#6c757d";
    ctx.font = "11px sans-serif";
    ctx.textAlign = "right";
    for (let k = 0; k <= 4; k++) {
      const gv = maxV - (k * range / 4);
      const gy = padTop + (k * plotH / 4);
      ctx.fillText(String(Math.round(gv)), padLeft - 6, gy + 3);
    }
    ctx.textAlign = "start";

    // Filled area under the line.
    ctx.fillStyle = "rgba(13,110,253,0.16)";
    ctx.beginPath();
    pts.forEach(function(p, i){
      const tsMs = Date.parse(p.ts || "");
      const xv = xByTs(tsMs), yv = y(Number(p[metric]));
      if (i === 0) ctx.moveTo(xv, yv);
      else ctx.lineTo(xv, yv);
    });
    const firstTs = Date.parse(pts[0].ts || "");
    const lastTs = Date.parse(pts[pts.length - 1].ts || "");
    ctx.lineTo(xByTs(lastTs), padTop + plotH);
    ctx.lineTo(xByTs(firstTs), padTop + plotH);
    ctx.closePath();
    ctx.fill();

    // Main line.
    ctx.strokeStyle = "#0d6efd";
    ctx.lineWidth = 2;
    ctx.beginPath();
    pts.forEach(function(p, i){
      const tsMs = Date.parse(p.ts || "");
      const xv = xByTs(tsMs), yv = y(Number(p[metric]));
      if (i === 0) ctx.moveTo(xv, yv);
      else ctx.lineTo(xv, yv);
    });
    ctx.stroke();

    ctx.fillStyle = "#0d6efd";
    pts.forEach(function(p){
      const tsMs = Date.parse(p.ts || "");
      const xv = xByTs(tsMs), yv = y(Number(p[metric]));
      ctx.beginPath();
      ctx.arc(xv, yv, 2.5, 0, Math.PI * 2);
      ctx.fill();
    });

    // X-axis time labels.
    ctx.fillStyle = "#6c757d";
    ctx.font = "11px sans-serif";
    ctx.textAlign = "center";
    for (let k = 0; k <= 5; k++) {
      const t = fromMs + (k * spanMs / 5);
      const gx = padLeft + (k * plotW / 5);
      ctx.fillText(formatTick(t, spanMs), gx, h - 10);
    }
    ctx.textAlign = "start";

    const last = pts[pts.length - 1];
    const lastVal = Number(last[metric]);
    const periodLabel = (period === "custom") ? "произвольный период" : (periodSelect.options[periodSelect.selectedIndex]?.text || period);
    hint.textContent = metricLabels[metric] + ": " + lastVal + " (точек: " + pts.length + ", " + periodLabel + ")";
  }

  function setActiveMetricButtons(){
    document.querySelectorAll("[data-chart-metric]").forEach(function(b){
      b.classList.toggle("active", b.getAttribute("data-chart-metric") === metric);
    });
  }

  function setPeriodUI(){
    periodSelect.value = period;
    customWrap.classList.toggle("d-none", period !== "custom");
  }

  function saveState(){
    try {
      localStorage.setItem(lsMetricKey, metric);
      localStorage.setItem(lsPeriodKey, period);
      if (period === "custom") {
        localStorage.setItem(lsFromKey, dateFrom.value || "");
        localStorage.setItem(lsToKey, dateTo.value || "");
      }
      localStorage.setItem(lsCollapsedKey, collapsed ? "1" : "0");
    } catch (_e) {}
  }

  function loadState(){
    try {
      const m = localStorage.getItem(lsMetricKey);
      const p = localStorage.getItem(lsPeriodKey);
      const f = localStorage.getItem(lsFromKey);
      const t = localStorage.getItem(lsToKey);
      const c = localStorage.getItem(lsCollapsedKey);
      if (m && metricLabels[m]) metric = m;
      if (p) period = p;
      if (f) dateFrom.value = f;
      if (t) dateTo.value = t;
      collapsed = (c === "1");
    } catch (_e) {}

    if (period !== "custom" && (!presetMinutes[period] || presetMinutes[period] > maxMinutes)) {
      period = "15m";
      if (presetMinutes[period] > maxMinutes) period = "7d";
      if (presetMinutes[period] > maxMinutes) period = "custom";
    }

    if (period === "custom") {
      const now = Date.now();
      if (!dateTo.value) dateTo.value = toLocalInputValue(now);
      if (!dateFrom.value) dateFrom.value = toLocalInputValue(now - (15 * 60 * 1000));
    }
  }

  document.querySelectorAll("[data-chart-metric]").forEach(function(btn){
    btn.addEventListener("click", function(){
      metric = btn.getAttribute("data-chart-metric") || "online";
      setActiveMetricButtons();
      saveState();
      draw();
    });
  });

  periodSelect.addEventListener("change", function(){
    period = periodSelect.value || "15m";
    setPeriodUI();
    saveState();
    draw();
  });

  customApply.addEventListener("click", function(){
    period = "custom";
    setPeriodUI();
    saveState();
    draw();
  });

  collapseBtn.addEventListener("click", function(){
    collapsed = !collapsed;
    applyCollapseState();
    saveState();
  });

  window.addEventListener("resize", draw);

  loadState();
  setActiveMetricButtons();
  setPeriodUI();
  applyCollapseState();
  draw();
})();
</script>
