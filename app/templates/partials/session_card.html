<div class="card shadow-sm">
  <div class="card-body">
    <h1 class="h6 mb-2">Сеанс</h1>

    <div class="row small">
      <div class="col-md-6">
        <div class="text-secondary">Пользователь: <strong>{{ user.get("username","") }}</strong></div>
        <div class="text-secondary">Тип: <strong>{{ user.get("auth","") }}</strong></div>
        <div class="text-secondary">Доступ к настройкам: <strong>{{ "Да" if user.get("settings") else "Нет" }}</strong></div>
      </div>
      <div class="col-md-6">
        <div class="text-secondary">Отображаемое имя: <strong>{{ user.get("display_name","") }}</strong></div>
      </div>
    </div>

    <div class="mt-3 pt-3 border-top">
      <div class="h6 mb-2">Статистика</div>

      <div class="row row-cols-1 row-cols-lg-5 g-2 align-items-end">
        <div class="col">
          <div class="text-secondary fs-4 text-lg-center">Пользователей AD: <span class="fw-semibold text-info fs-4">{{ ad_users_total }}</span></div>
        </div>

        <div class="col">
          <div class="text-secondary fs-4 text-lg-center">Активных: <span class="fw-semibold text-info fs-4">{{ ad_users_enabled }}</span></div>
        </div>

        {% if net_scan_ready %}
        <div class="col">
          <div class="text-secondary fs-4 text-lg-center">Онлайн: <span class="fw-semibold text-info fs-4">{{ matches_last_scan }}</span></div>
        </div>

        <div class="col">
          <div class="text-secondary fs-4 text-lg-center">Общих папок: <span class="fw-semibold text-info fs-4">{{ shares_visible }}</span></div>
        </div>

        <div class="col">
          <div class="text-secondary fs-4 text-lg-center">Скрытых шар: <span class="fw-semibold text-info fs-4">{{ shares_hidden }}</span></div>
        </div>
        {% else %}
        <div class="col">
          <div class="text-secondary fs-4 text-lg-center">Онлайн: <span class="fw-semibold text-info fs-4">{{ online_users }}</span></div>
        </div>
        {% endif %}
      </div>
    </div>

    <div class="mt-3 pt-3 border-top">
      <div class="d-flex flex-wrap align-items-center justify-content-between gap-2 mb-2">
        <div class="fw-semibold">Динамика метрик</div>
        <button type="button" class="btn btn-sm btn-outline-secondary" id="stats-chart-collapse-btn">Свернуть</button>
      </div>

      <div id="stats-chart-wrap">
        <div class="d-flex flex-wrap align-items-center gap-2 mb-2">
          <div class="btn-group btn-group-sm" role="group" aria-label="Метрика графика">
            <button type="button" class="btn btn-outline-primary" data-chart-metric="total">Всего пользователей</button>
            <button type="button" class="btn btn-outline-primary" data-chart-metric="enabled">Активных</button>
            <button type="button" class="btn btn-outline-primary active" data-chart-metric="online">Онлайн</button>
          </div>
          <select class="form-select form-select-sm" id="stats-period-select" style="width:auto;">
            <option value="1h" selected>Последний 1 час</option>
            <option value="3h">Последние 3 часа</option>
            <option value="6h">Последние 6 часов</option>
            <option value="12h">Последние 12 часов</option>
            <option value="24h">Последние 24 часа</option>
            <option value="7d">Последние 7 дней</option>
            <option value="30d">Последние 30 дней</option>
            <option value="90d">Последние 3 месяца</option>
            <option value="180d">Последние 6 месяцев</option>
            <option value="365d">Последние 12 месяцев</option>
            <option value="custom">Произвольный период</option>
          </select>
        </div>

        <div class="d-flex flex-wrap align-items-center gap-2 mb-2 d-none" id="stats-custom-range">
          <label class="small text-secondary" for="stats-date-from">С</label>
          <input id="stats-date-from" type="datetime-local" class="form-control form-control-sm" style="max-width:220px;">
          <label class="small text-secondary" for="stats-date-to">По</label>
          <input id="stats-date-to" type="datetime-local" class="form-control form-control-sm" style="max-width:220px;">
          <button type="button" class="btn btn-sm btn-outline-primary" id="stats-custom-apply">Применить</button>
        </div>

        <canvas id="stats-chart-canvas" height="170" style="display:block; width:calc(100% - 20px); margin:0 10px;"></canvas>
        <div id="stats-chart-hint" class="small text-secondary mt-1"></div>
      </div>
    </div>

    <div class="mt-3 pt-2 border-top small text-secondary">
      <div class="mb-1">Статус: {% if net_scan_is_running %}<span class="badge text-bg-info">Выполняется…</span>{% else %}<span class="badge text-bg-secondary">Ожидание</span>{% endif %}</div>
      <div>Сканирований (за период хранения): <strong>{{ stats_scans_total or 0 }}</strong></div>
      <div>Последний запуск: <strong>{{ net_scan_last_run if net_scan_last_run else "—" }}</strong></div>
      <div>Результат: {% if net_scan_last_summary %}{{ net_scan_last_summary }}{% else %}—{% endif %}</div>
    </div>
  </div>
</div>

<script>
(function(){
  const points = {{ stats_history_points|tojson }};
  const retentionDays = Number({{ stats_retention_days or 30 }});
  const canvas = document.getElementById("stats-chart-canvas");
  const hint = document.getElementById("stats-chart-hint");
  const periodSelect = document.getElementById("stats-period-select");
  const customWrap = document.getElementById("stats-custom-range");
  const dateFrom = document.getElementById("stats-date-from");
  const dateTo = document.getElementById("stats-date-to");
  const customApply = document.getElementById("stats-custom-apply");
  const collapseBtn = document.getElementById("stats-chart-collapse-btn");
  const chartWrap = document.getElementById("stats-chart-wrap");
  if (!canvas || !hint || !periodSelect || !customWrap || !dateFrom || !dateTo || !customApply || !collapseBtn || !chartWrap) return;

  const metricLabels = {
    total: "Всего пользователей",
    enabled: "Активных",
    online: "Онлайн"
  };
  const presetMinutes = {
    "1h": 60,
    "3h": 180,
    "6h": 360,
    "12h": 720,
    "24h": 1440,
    "7d": 7 * 1440,
    "30d": 30 * 1440,
    "90d": 90 * 1440,
    "180d": 180 * 1440,
    "365d": 365 * 1440
  };
  const maxMinutes = Math.max(1, retentionDays * 1440);

  Array.from(periodSelect.options).forEach(function(opt){
    if (Object.prototype.hasOwnProperty.call(presetMinutes, opt.value)) {
      opt.disabled = presetMinutes[opt.value] > maxMinutes;
    }
  });

  let metric = "online";
  let period = "1h";
  let collapsed = false;
  const lsMetricKey = "ad_portal_stats_metric";
  const lsPeriodKey = "ad_portal_stats_period";
  const lsFromKey = "ad_portal_stats_from";
  const lsToKey = "ad_portal_stats_to";
  const lsCollapsedKey = "ad_portal_stats_collapsed";

  function parseLocalDateInput(s){
    const ms = Date.parse(s || "");
    return Number.isFinite(ms) ? ms : null;
  }

  function toLocalInputValue(ms){
    if (!Number.isFinite(ms)) return "";
    const d = new Date(ms);
    const pad = function(n){ return String(n).padStart(2, "0"); };
    return d.getFullYear() + "-" + pad(d.getMonth() + 1) + "-" + pad(d.getDate()) + "T" + pad(d.getHours()) + ":" + pad(d.getMinutes());
  }

  function applyCollapseState(){
    chartWrap.classList.toggle("d-none", collapsed);
    collapseBtn.textContent = collapsed ? "Развернуть" : "Свернуть";
  }

  function getPeriodWindowMs() {
    let fromMs = null;
    let toMs = Date.now();

    if (period === "custom") {
      fromMs = parseLocalDateInput(dateFrom.value);
      const customTo = parseLocalDateInput(dateTo.value);
      if (customTo !== null) toMs = customTo;
      if (fromMs === null) return null;
      if (toMs < fromMs) return null;
    } else {
      const mins = presetMinutes[period] || 15;
      fromMs = Date.now() - (mins * 60 * 1000);
    }
    return { fromMs: fromMs, toMs: toMs };
  }

  function pickPeriodPoints(windowMs) {
    if (!Array.isArray(points) || !points.length || !windowMs) return [];
    const fromMs = windowMs.fromMs;
    const toMs = windowMs.toMs;
    const out = points.filter(function(p){
      const ts = Date.parse(p.ts || "");
      return Number.isFinite(ts) && ts >= fromMs && ts <= toMs;
    });
    out.sort(function(a, b){
      return Date.parse(a.ts || "") - Date.parse(b.ts || "");
    });
    return out;
  }

  function formatTick(ms, spanMs){
    const d = new Date(ms);
    if (spanMs <= 24 * 60 * 60 * 1000) {
      return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }
    if (spanMs <= 45 * 24 * 60 * 60 * 1000) {
      return d.toLocaleDateString([], { day: "2-digit", month: "2-digit" }) + " " +
             d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    }
    return d.toLocaleDateString([], { day: "2-digit", month: "2-digit", year: "2-digit" });
  }

  function draw(){
    const windowMs = getPeriodWindowMs();
    if (!windowMs) {
      hint.textContent = "Некорректный период (проверьте даты 'С' и 'По').";
      return;
    }
    const fromMs = windowMs.fromMs;
    const toMs = windowMs.toMs;
    const spanMs = Math.max(1, toMs - fromMs);

    const pts = pickPeriodPoints(windowMs).filter(function(p){
      return p[metric] !== null && p[metric] !== undefined;
    });

    const ctx = canvas.getContext("2d");
    const containerWidth = (canvas.parentElement && canvas.parentElement.clientWidth) ? canvas.parentElement.clientWidth : canvas.clientWidth;
    const w = Math.max(320, (containerWidth || 640) - 20);
    const h = 200;
    canvas.width = w;
    canvas.height = h;

    ctx.clearRect(0, 0, w, h);

    const padTop = 12;
    const padBottom = 32;
    const padLeft = 52;
    const padRight = 10;
    const plotH = Math.max(1, h - padTop - padBottom);
    const plotW = Math.max(1, w - padLeft - padRight);

    // Axes and grid (Grafana/Zabbix-like look)
    ctx.strokeStyle = "rgba(108,117,125,0.25)";
    ctx.lineWidth = 1;
    for (let k = 0; k <= 4; k++) {
      const gy = padTop + (k * plotH / 4);
      ctx.beginPath();
      ctx.moveTo(padLeft, gy);
      ctx.lineTo(w - padRight, gy);
      ctx.stroke();
    }
    for (let k = 0; k <= 5; k++) {
      const gx = padLeft + (k * plotW / 5);
      ctx.beginPath();
      ctx.moveTo(gx, padTop);
      ctx.lineTo(gx, padTop + plotH);
      ctx.stroke();
    }

    if (!pts.length) {
      ctx.fillStyle = "#6c757d";
      ctx.font = "13px sans-serif";
      ctx.fillText("Недостаточно данных за выбранный период.", padLeft + 8, padTop + 16);
      hint.textContent = "Недостаточно данных за выбранный период. Точки добавляются после каждого завершённого сканирования.";
      // Draw time scale even without points.
      ctx.fillStyle = "#6c757d";
      ctx.font = "11px sans-serif";
      ctx.textAlign = "center";
      for (let k = 0; k <= 5; k++) {
        const t = fromMs + (k * spanMs / 5);
        const gx = padLeft + (k * plotW / 5);
        ctx.fillText(formatTick(t, spanMs), gx, h - 10);
      }
      ctx.textAlign = "start";
      return;
    }

    const values = pts.map(function(p){ return Number(p[metric]); });
    const minV = Math.min.apply(null, values);
    const maxV = Math.max.apply(null, values);
    const range = Math.max(1, maxV - minV);

    function xByTs(tsMs){
      const ratio = (tsMs - fromMs) / spanMs;
      const clamped = Math.min(1, Math.max(0, ratio));
      return padLeft + (clamped * plotW);
    }
    function y(v){
      return padTop + ((maxV - v) * plotH / range);
    }

    function traceSmoothLine(points){
      if (!points.length) return;
      if (points.length === 1) {
        ctx.moveTo(points[0].x, points[0].y);
        return;
      }
      if (points.length === 2) {
        ctx.moveTo(points[0].x, points[0].y);
        ctx.lineTo(points[1].x, points[1].y);
        return;
      }
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length - 1; i++) {
        const mx = (points[i].x + points[i + 1].x) / 2;
        const my = (points[i].y + points[i + 1].y) / 2;
        ctx.quadraticCurveTo(points[i].x, points[i].y, mx, my);
      }
      const last = points[points.length - 1];
      const prev = points[points.length - 2];
      ctx.quadraticCurveTo(prev.x, prev.y, last.x, last.y);
    }

    // Y-axis labels.
    ctx.fillStyle = "#6c757d";
    ctx.font = "11px sans-serif";
    ctx.textAlign = "right";
    for (let k = 0; k <= 4; k++) {
      const gv = maxV - (k * range / 4);
      const gy = padTop + (k * plotH / 4);
      ctx.fillText(String(Math.round(gv)), padLeft - 6, gy + 3);
    }
    ctx.textAlign = "start";

    const chartPoints = pts.map(function(p){
      const tsMs = Date.parse(p.ts || "");
      return { x: xByTs(tsMs), y: y(Number(p[metric])) };
    });

    // Filled area under the line (smoothed).
    ctx.fillStyle = "{{ stats_chart_fill_color or 'rgba(13,110,253,0.16)' }}";
    ctx.beginPath();
    traceSmoothLine(chartPoints);
    const firstPoint = chartPoints[0];
    const lastPoint = chartPoints[chartPoints.length - 1];
    ctx.lineTo(lastPoint.x, padTop + plotH);
    ctx.lineTo(firstPoint.x, padTop + plotH);
    ctx.closePath();
    ctx.fill();

    // Main line (smoothed).
    ctx.strokeStyle = "{{ stats_chart_line_color or '#0d6efd' }}";
    ctx.lineWidth = 2;
    ctx.beginPath();
    traceSmoothLine(chartPoints);
    ctx.stroke();

    if ({{ 'true' if stats_chart_show_points else 'false' }}) {
      ctx.fillStyle = "{{ stats_chart_point_color or '#0d6efd' }}";
      chartPoints.forEach(function(pt){
        ctx.beginPath();
        ctx.arc(pt.x, pt.y, 2.5, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // X-axis time labels.
    ctx.fillStyle = "#6c757d";
    ctx.font = "11px sans-serif";
    ctx.textAlign = "center";
    for (let k = 0; k <= 5; k++) {
      const t = fromMs + (k * spanMs / 5);
      const gx = padLeft + (k * plotW / 5);
      ctx.fillText(formatTick(t, spanMs), gx, h - 10);
    }
    ctx.textAlign = "start";

    const last = pts[pts.length - 1];
    const lastVal = Number(last[metric]);
    const periodLabel = (period === "custom") ? "произвольный период" : (periodSelect.options[periodSelect.selectedIndex]?.text || period);
    hint.textContent = metricLabels[metric] + ": " + lastVal + " (точек: " + pts.length + ", " + periodLabel + ")";
  }

  function setActiveMetricButtons(){
    document.querySelectorAll("[data-chart-metric]").forEach(function(b){
      b.classList.toggle("active", b.getAttribute("data-chart-metric") === metric);
    });
  }

  function setPeriodUI(){
    periodSelect.value = period;
    customWrap.classList.toggle("d-none", period !== "custom");
  }

  function saveState(){
    try {
      localStorage.setItem(lsMetricKey, metric);
      localStorage.setItem(lsPeriodKey, period);
      if (period === "custom") {
        localStorage.setItem(lsFromKey, dateFrom.value || "");
        localStorage.setItem(lsToKey, dateTo.value || "");
      }
      localStorage.setItem(lsCollapsedKey, collapsed ? "1" : "0");
    } catch (_e) {}
  }

  function loadState(){
    try {
      const m = localStorage.getItem(lsMetricKey);
      const p = localStorage.getItem(lsPeriodKey);
      const f = localStorage.getItem(lsFromKey);
      const t = localStorage.getItem(lsToKey);
      const c = localStorage.getItem(lsCollapsedKey);
      if (m && metricLabels[m]) metric = m;
      if (p) period = p;
      if (f) dateFrom.value = f;
      if (t) dateTo.value = t;
      collapsed = (c === "1");
    } catch (_e) {}

    if (period !== "custom" && (!presetMinutes[period] || presetMinutes[period] > maxMinutes)) {
      period = "1h";
      if (presetMinutes[period] > maxMinutes) period = "7d";
      if (presetMinutes[period] > maxMinutes) period = "custom";
    }

    if (period === "custom") {
      const now = Date.now();
      if (!dateTo.value) dateTo.value = toLocalInputValue(now);
      if (!dateFrom.value) dateFrom.value = toLocalInputValue(now - (60 * 60 * 1000));
    }
  }

  document.querySelectorAll("[data-chart-metric]").forEach(function(btn){
    btn.addEventListener("click", function(){
      metric = btn.getAttribute("data-chart-metric") || "online";
      setActiveMetricButtons();
      saveState();
      draw();
    });
  });

  periodSelect.addEventListener("change", function(){
    period = periodSelect.value || "1h";
    setPeriodUI();
    saveState();
    draw();
  });

  customApply.addEventListener("click", function(){
    period = "custom";
    setPeriodUI();
    saveState();
    draw();
  });

  collapseBtn.addEventListener("click", function(){
    collapsed = !collapsed;
    applyCollapseState();
    saveState();
  });

  window.addEventListener("resize", draw);

  loadState();
  setActiveMetricButtons();
  setPeriodUI();
  applyCollapseState();
  draw();
})();
</script>
